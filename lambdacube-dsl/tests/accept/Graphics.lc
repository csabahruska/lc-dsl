module Graphics where

import Material hiding (Blending)

infixl 6 +., +, -., -
infixl 7 *., *, /., /
infix  4 <, <=, >, >=

(+.) = PrimAddS
(+) = PrimAdd
(-.) = PrimSubS
(-) = PrimSub
(*.) = PrimMulS
(*) = PrimMul
(/.) = PrimDivS
(/) = PrimDiv
(<) = PrimLessThan
(<=) = PrimLessThanEqual
(>) = PrimGreaterThan
(>=) = PrimGreaterThanEqual
otherwise = True
clamp' = PrimClamp
sin' = PrimSin
cos' = PrimCos
zero' = zeroComp
one' = oneComp
normalize' = PrimNormalize
texture' = PrimTexture

singT = id

-- specialized snoc
v3v4 :: Vec 3 Float -> Vec 4 Float
v3v4 (V3 x y z) = V4 x y z 1

v4v3 :: Vec 4 Float -> Vec 3 Float
v4v3 (V4 x y z _) = V3 x y z

-- specialized snoc
snoc :: Vec 3 Float -> Float -> Vec 4 Float
snoc (V3 x y z) s = V4 x y z s

snoc' :: Vec 3 Float -> Float -> Vec 4 Float
snoc' (V3 x y z) s = V4 x y z s

drop4 :: Vec 4 Float -> Vec 3 Float
drop4 (V4 x y z _) = V3 x y z

drop3 :: Vec 3 Float -> Vec 2 Float
drop3 (V3 x y _) = V2 x y

mkRasterContext :: CommonAttrs -> RasterContext Triangle
mkRasterContext ca = TriangleCtx cull PolygonFill offset LastVertex
  where
    offset  = if caPolygonOffset ca then Offset (-1) (-2) else NoOffset
    cull = case caCull ca of
        CT_FrontSided   -> CullFront CCW
        CT_BackSided    -> CullBack CCW
        CT_TwoSided     -> CullNone

--mkAccumulationContext :: StageAttrs -> AccumulationContext (Depth Float, Color (Vec 4 Float))
mkAccumulationContext sa = AccumulationContext (DepthOp depthFunc depthWrite, ColorOp blend (one' :: Vec 4 Bool))
  where
    depthWrite  = saDepthWrite sa
    depthFunc   = case saDepthFunc sa of
        D_Equal     -> Equal
        D_Lequal    -> Lequal
    cvt b = case b of
        B_DstAlpha          -> DstAlpha
        B_DstColor          -> DstColor
        B_One               -> One
        B_OneMinusDstAlpha  -> OneMinusDstAlpha
        B_OneMinusDstColor  -> OneMinusDstColor
        B_OneMinusSrcAlpha  -> OneMinusSrcAlpha
        B_OneMinusSrcColor  -> OneMinusSrcColor
        B_SrcAlpha          -> SrcAlpha
        B_SrcAlphaSaturate  -> SrcAlphaSaturate
        B_SrcColor          -> SrcColor
        B_Zero              -> Zero
    blend       = case saBlend sa of
        Nothing     -> NoBlending
        Just (src,dst)  -> Blend (FuncAdd,FuncAdd) ((srcF,dstF),(srcF,dstF)) zero'
          where
            srcF    = cvt src
            dstF    = cvt dst

mkWave' :: Float -> Wave -> Float
mkWave' off (Wave wFunc base amplitude phase freq) = base +. a *. amplitude
  where
    time        = Uni (IFloat "time") :: Float
    u           = off +. phase +. freq *. time
    uv          = V2 u 0
    sampler     = () -- TODO --  Sampler LinearFilter Repeat $ TextureSlot name (Texture2D (Float RGBA) n1)
    V4 v _ _ _  = texture' sampler uv
    a           = v *. 2 -. 1
    name        = case wFunc of
        WT_Sin              -> "SinTable"
        WT_Triangle         -> "TriangleTable"
        WT_Square           -> "SquareTable"
        WT_Sawtooth         -> "SawToothTable"
        WT_InverseSawtooth  -> "InverseSawToothTable"
        WT_Noise            -> "Noise"

mkWave :: Wave -> Float
mkWave = mkWave' 0

mkColor :: CommonAttrs -> StageAttrs -> Vec 4 Float -> Vec 4 Float      -- V frequency
mkColor ca sa rgbaV = snoc' rgb alpha
  where
    entityRGB       = Uni (IV3F "entityRGB") :: Vec 3 Float
    entityAlpha     = Uni (IFloat "entityAlpha") :: Float
    identityLight'   = Uni (IFloat "identityLight") :: Float
    --red             = V3 1 0 0
    green           = V3 0 1 0
    V4 rV gV bV aV  = rgbaV
    rgb = case saRGBGen sa of
        RGB_Wave w              -> let c = mkWave w in V3 c c c
        RGB_Const r g b         -> V3 r g b
        RGB_Identity            -> one'
        RGB_IdentityLighting    -> V3 identityLight' identityLight' identityLight'
        RGB_Entity              -> entityRGB
        RGB_OneMinusEntity      -> one' - entityRGB
        RGB_ExactVertex         -> V3 rV gV bV
        RGB_Vertex              -> (V3 rV gV bV) *. identityLight'
        RGB_LightingDiffuse     -> green -- TODO
        {-  input:
                entity: ambientLight
                        directedLight
                        lightDir
                model:  position
                        normal
        -}
        RGB_OneMinusVertex      -> one' - ((V3 rV gV bV) *. identityLight')

    alpha = case saAlphaGen sa of
        A_Wave w            -> let a = mkWave w in clamp' a 0 1
        A_Const a           -> a
        A_Portal            -> 1 -- TODO
        A_Identity          -> 1
        A_Entity            -> entityAlpha
        A_OneMinusEntity    -> 1 -. entityAlpha
        A_Vertex            -> aV
        A_LightingSpecular  -> 1 -- TODO
        {-  input:
                model:  position
                        normal
                user:   viewOrigin
        -}
        A_OneMinusVertex    -> 1 -. aV

mkDeform :: Vec 2 Float -> Vec 3 Float -> Vec 3 Float -> Deform -> Vec 3 Float
mkDeform uv normal pos d = case d of
    D_Move (V3 x y z) w   -> pos + ((V3 x y z) *. mkWave w)
    D_Wave spread w@(Wave _ _ _ _ f)
        | f < 0.000001  -> pos + (normal *. mkWave w)
        | otherwise     ->
            let V3 x y z    = pos
                off         = (x +. y +. z) *. spread
            in pos + (normal *. mkWave' off w)
    D_Bulge w h s   -> let time     = Uni (IFloat "time") :: Float
                           V2 u _   = uv
                           now      = time *. s
                           off      = u *. w +. now
                       in pos + (normal *. sin' off *. h)
    _ -> pos

{-
data TCMod
    = TM_EntityTranslate
-}
mkTCMod :: Vec 3 Float -> Vec 2 Float -> TCMod -> Vec 2 Float
mkTCMod pos uv m = {- trace (show m) $ -} case m of
    TM_Scroll su sv -> uv + ((V2 su sv :: Vec 2 Float) *. (Uni (IFloat "time") :: Float))
    TM_Scale su sv  -> uv * (V2 su sv :: Vec 2 Float)
    TM_Stretch w    -> let p    = 1 /. mkWave w 
                           v0_5 = 0.5
                           off  = v0_5 -. v0_5 *. p
                       in (uv *. p) +. off
    TM_Rotate speed -> let time = Uni (IFloat "time") :: Float
                           fi   = (-speed *. pi /. 180) *. time
                           s    = sin' fi
                           ms   = s *. (-1)
                           c    = cos' fi
                           mA   = V2 c s
                           mB   = V2 ms c
                           m'   = M22F mA mB
                           v0_5 = 0.5
                           off  = V2 (v0_5 -. v0_5 *. c +. v0_5 *. s) (v0_5 -. v0_5 *. s -. v0_5 *. c)
                       in (m' `PrimMulMatVec` uv) + off
    TM_Transform m00 m01 m10 m11 t0 t1  -> let V2 u v   = uv
                                               u'       = u *. m00 +. v *. m10 +. t0
                                               v'       = u *. m01 +. v *. m11 +. t1
                                           in V2 u' v'
    TM_Turb base amp phase freq ->  let V2 u v      = uv
                                        V3 x y z    = pos
                                        time        = Uni (IFloat "time") :: Float
                                        now         = phase +. time *. freq
                                        offU        = (2 *. pi) *. ((x +. z) *. (0.125 /. 128) +. now)
                                        offV        = (2 *. pi) *. (y *. (0.125 /. 128) +. now)
                                    in uv + (sin' (V2 offU offV) *. amp)
    _ -> uv

mkTexCoord :: Vec 3 Float -> Vec 3 Float -> StageAttrs -> Vec 2 Float -> Vec 2 Float -> Vec 2 Float
mkTexCoord pos normal sa uvD uvL = foldl' (mkTCMod pos) uv $ saTCMod sa
  where
    uv = case saTCGen sa of
        TG_Base         -> uvD
        TG_Lightmap     -> uvL
        TG_Environment  ->  let viewOrigin  = Uni (IV3F "viewOrigin")
                                viewer      = normalize' $ viewOrigin - pos
                                d           = normal `PrimDot` viewer
                                reflected   = (normal *. (2 *. d)) - viewer
                                V3 _ y z    = reflected
                                v0_5        = 0.5
                            in V2 (v0_5 +. y *. v0_5) (v0_5 -. z *. v0_5)
        TG_Vector (V3 sx sy sz) (V3 tx ty tz)       -> let s    = V3 sx sy sz :: Vec 3 Float
                                                           t    = V3 tx ty tz :: Vec 3 Float
                                                       in V2 (pos `PrimDot` s) (pos `PrimDot` t)

mkVertexShader :: CommonAttrs -> StageAttrs -> (Vec 3 Float,Vec 3 Float,Vec 2 Float,Vec 2 Float,Vec 4 Float) -> VertexOut (Vec 2 Float,Vec 4 Float)
mkVertexShader ca sa (p,n,d,l,c) = VertexOut screenPos 1 () (Smooth uv, Smooth color)
  where
    worldMat    = Uni (IM44F "worldMat")
    viewMat     = Uni (IM44F "viewMat")
    viewProj    = Uni (IM44F "viewProj")
    pos         = foldl' (mkDeform d n) p $ caDeformVertexes ca
    screenPos   = viewProj `PrimMulMatVec` (worldMat `PrimMulMatVec` snoc pos 1)
    norm        = drop4 $ (viewMat `PrimMulMatVec` (worldMat `PrimMulMatVec` snoc n 0))
    uv          = mkTexCoord pos n sa d l
    color       = mkColor ca sa c

data EdgeMode = Repeat | MirroredRepeat | ClampToEdge | ClampToBorder

mkFragmentShader :: StageAttrs -> (Vec 2 Float,Vec 4 Float) -> FragmentOut (Depth Float, Color (Vec 4 Float))
mkFragmentShader sa uvrgba = FragmentOutRastDepth color
  where
    (uv,rgba)   = uvrgba
    stageTex    = saTexture sa
    stageTexN   = "" -- TODO -- SB.pack $ "Tex_" ++ show (crc32 $ SB.pack $ show stageTex)
    texColor em name = texture' sampler uv
      where
        sampler     = () -- TODO -- Sampler LinearFilter em $ TextureSlot name (Texture2D (Float RGBA) n1)
    color       = case stageTex of
        ST_WhiteImage   -> rgba
        ST_Lightmap     -> rgba * texColor ClampToEdge "LightMap"
        ST_Map _        -> rgba * texColor Repeat  stageTexN
        ST_ClampMap _   -> rgba * texColor ClampToEdge stageTexN
        ST_AnimMap _ _  -> rgba * texColor Repeat  stageTexN

mkFilterFunction :: StageAttrs -> FragmentFilter (Vec 2 Float,Vec 4 Float)
mkFilterFunction sa = case saAlphaFunc sa of
    Nothing -> PassAll
    Just f  -> Filter $ \uvrgba ->
        let
            (uv,rgba)   = uvrgba
            stageTex    = saTexture sa
            stageTexN   = "" -- TODO -- SB.pack $ "Tex_" ++ show (crc32 $ SB.pack $ show stageTex)
            texColor em name = texture' sampler uv
              where
                sampler     = () -- TODO -- Sampler LinearFilter em $ TextureSlot name (Texture2D (Float RGBA) n1)
            color       = case stageTex of
                ST_WhiteImage   -> rgba
                ST_Lightmap     -> rgba * texColor ClampToEdge "LightMap"
                ST_Map _        -> rgba * texColor Repeat  stageTexN
                ST_ClampMap _   -> rgba * texColor ClampToEdge stageTexN
                ST_AnimMap _ _  -> rgba * texColor Repeat  stageTexN
            V4 _ _ _ a  = color
        in case {- trace ("alpha filter: " ++ show f) -} f of
            A_Gt0   -> a > 0
            A_Lt128 -> a < 0.5
            A_Ge128 -> a >= 0.5

mkStage :: String -> CommonAttrs -> (FrameBuffer 1 (Float,Vec 4 Float)) -> StageAttrs -> (FrameBuffer 1 (Float,Vec 4 Float))
mkStage name ca prevFB sa = Accumulate aCtx fFun fSh (Rasterize rCtx (Transform vSh input)) prevFB
  where
    input   = Fetch name Triangles (IV3F "position", IV3F "normal", IV2F "diffuseUV", IV2F "lightmapUV", IV4F "color")
    rCtx    = mkRasterContext ca
    aCtx    = mkAccumulationContext sa
    vSh     = mkVertexShader ca sa
    fSh     = mkFragmentShader sa
    fFun    = mkFilterFunction sa

mkShader :: (FrameBuffer 1 (Float,Vec 4 Float)) -> (String,CommonAttrs) -> (FrameBuffer 1 (Float,Vec 4 Float))
mkShader fb (name,ca) = foldl' (mkStage name ca) fb $ caStages ca

errorShaderFill :: (FrameBuffer 1 (Float,Vec 4 Float)) -> (FrameBuffer 1 (Float,Vec 4 Float))
errorShaderFill fb = Accumulate fragCtx PassAll frag rast fb
  where
    worldMat = Uni (IM44F "worldMat")
    viewProj = Uni (IM44F "viewProj")

    vert :: (Vec 3 Float,Vec 4 Float) -> VertexOut (Vec 4 Float)
    vert (p,c) = VertexOut v4 1 () (singT $ Smooth c')
      where
        v4    = viewProj `PrimMulMatVec` (worldMat `PrimMulMatVec` snoc p 1)
        V4 r g b _  = c
        c'          = V4 r g b 0.5

    blend   = Blend (FuncAdd,Min) ((One,One),(One,One)) one'
    fragCtx = AccumulationContext (DepthOp Less False, ColorOp blend (one' :: Vec 4 Bool))
    rastCtx = TriangleCtx CullNone PolygonFill NoOffset LastVertex
    input   = Fetch "missing shader" Triangles (IV3F "position", IV4F "color")
    prims   = Transform vert input
    rast    = Rasterize rastCtx prims

    frag :: Vec 4 Float -> FragmentOut (Depth Float, Color (Vec 4 Float))
    frag v = FragmentOutRastDepth $ singT v

errorShader :: (FrameBuffer 1 (Float,Vec 4 Float)) -> (FrameBuffer 1 (Float,Vec 4 Float))
errorShader fb = Accumulate fragCtx PassAll frag rast $ errorShaderFill fb
  where
    viewProj = Uni (IM44F "viewProj")
    worldMat = Uni (IM44F "worldMat")

    vert :: (Vec 3 Float,Vec 4 Float) -> VertexOut (Vec 4 Float)
    vert (p,c) = VertexOut v4 1 () (Smooth c)
      where
        v4    = viewProj `PrimMulMatVec` (worldMat `PrimMulMatVec` snoc p 1)

    offset  = NoOffset--Offset (0) (-10)
    fragCtx = AccumulationContext (DepthOp Lequal True, ColorOp NoBlending (one' :: Vec 4 Bool))
    rastCtx = TriangleCtx CullNone (PolygonLine 1) offset LastVertex
    input   = Fetch "missing shader" Triangles (IV3F "position", IV4F "color")
    prims   = Transform vert input
    rast    = Rasterize rastCtx prims

    frag :: Vec 4 Float -> FragmentOut (Depth Float, Color (Vec 4 Float))
    frag v = FragmentOutRastDepth $ v'
      where
        V4 r g b _  = v
        one         = 1
        v'          = V4 (one -. r) (one -. g) (one -. b) one
q3GFX :: [(String,CommonAttrs)] -> (FrameBuffer 1 (Float,Vec 4 Float))
q3GFX shl = {-blurVH $ PrjFrameBuffer "" tix0 $ -}errorShader $ foldl' mkShader clear ordered
  where
    ordered = sortBy (\(_,a) (_,b) -> caSort a `compare` caSort b) shl
    clear   = FrameBuffer (depthImage1 1000, colorImage1 (zero'::Vec 4 Float))

--main :: Output
main = ScreenOut $ q3GFX [("a",defaultCommonAttrs)]

