module ShadowMapping where
--module ShadowMapping(($),showPerson) where

import Data.Array
import Data.Array (null)
{-
import Utility
-}

type Entry = { firstName :: String, lastName :: String, phone :: String }

type PhoneBook = List Entry

value =
  let example = { firstName: "John", lastName: "Smith", phone: "555-555-5555" }
  in example

map (\n -> n + 1) [1, 2, 3, 4, 5]
(\n -> n + 1) `map` [1, 2, 3, 4, 5]

(..) :: Number -> Number -> [Number]
(..) = range

infix 5 ..

($) :: forall a b. (a -> b) -> a -> b
($) f x = f x

showPerson :: forall r. { first :: String, last :: String | r } -> String
showPerson { first = x, last = y } = y ++ ", " ++ x

class Functor f where
  (<$>) :: forall a b. (a -> b) -> f a -> f b

class Foldable f where
  foldr :: forall a b. (a -> b -> b) -> b -> f a -> b
  foldl :: forall a b. (b -> a -> b) -> b -> f a -> b
  foldMap :: forall a m. (Monoid m) => (a -> m) -> f a -> m

foldStream :: forall l e m. (Stream l e, Monoid m) => (e -> m) -> l -> m
foldStream f list =
  case uncons list of
    Nothing -> mempty
    Just (Tuple head tail) -> f head <> foldStream f tail

class Partial

head :: forall a. (Partial) => [a] -> a
head (x : _) = x

class (Monoid m) <= Action m a where
   act :: m -> a -> a

fullName :: forall r. { firstName :: String, lastName :: String | r } -> String
fullName person = person.firstName ++ " " ++ person.lastName

fullName :: forall r. Object (firstName :: String, lastName :: String | r) -> String
{-
> :k Object
  # * -> *
-}
main :: Screen
main = screen

{-
  done - module
  done - import
  done - type signature
  done - type def: type A = Int ; type R = forall r.{a::Int, b::Char}
  value def: id x = x ; c = "" ; head a@(x:_) = x ; toZero _ = 0
  class def
  instance def
  case
  infix application: id `map` 1
  fixity definition: infix 5 ..
  algebraic data type definition: data Bool = True | False
  let in
  where
  if then else
-}
